/*
Wavetrend

SD01-L Water Temperature Monitor Uplink Payload Formatter for TTN

https://www.thethingsindustries.com/docs/integrations/payload-formatters/javascript/
*/

/**
 * @typedef {Object} Wavetrend.SD01L.Version
 * @property {number} major
 * @property {number} minor
 * @property {number} build
 */
/**
 * Issued by device when installed to acquire operating configuration
 * @typedef {Wavetrend.SD01L.Payload_Header} Wavetrend.SD01L.InstallRequest
 * @property {number} nonce
 * @property {number} battery_mV
 * @property {number[]} temperature
 * @property {Wavetrend.SD01L.Version} firmware_version
 * @property {number} reset_reason
 */

/**
 * Issued by device after successfully receiving operating configuration
 * @typedef {Wavetrend.SD01L.Payload_Header} Wavetrend.SD01L.InstallResponse
 * @property {number} error
 */

/**
 * Standard sensor temperature readings
 * @typedef {Object} Wavetrend.SD01L.SensorReadings
 * @property {number} minC
 * @property {number} maxC
 * @property {number} events
 * @property {number} reports
 */

/**
 * Sensor reading histories (if enabled)
 * @typedef {{ timestamp: number, sensor: Wavetrend.SD01L.SensorReadings[] }} Wavetrend.SD01L.SensorHistory
 */

/**
 * Issued by the device at the standard report interval
 * @typedef {Wavetrend.SD01L.Payload_Header} Wavetrend.SD01L.StandardReport
 * @property {{ sensor: Wavetrend.SD01L.SensorReadings[] }} current
 * @property {Wavetrend.SD01L.SensorHistory[]} history
 */

/**
 * Issued by the device if ambient reporting is enabled
 * @typedef {Wavetrend.SD01L.Payload_Header} Wavetrend.SD01L.AmbientReport
 * @property {number} minC
 * @property {number} maxC
 * @property {number} avgC
 */

/**
 * Issued by the device if freeze reporting is enabled
 * @typedef {Wavetrend.SD01L.Payload_Header} Wavetrend.SD01L.FreezeReport
 * @property {number} sensor
 * @property {number} temperature
 */

/**
 * Issued by the device if scald reporting is enabled
 * @typedef {Wavetrend.SD01L.Payload_Header} Wavetrend.SD01L.ScaldReport
 * @property {number} sensor
 * @property {number} temperature
 */

/**
 * Issued by the device if a sensor error is detected
 * @typedef {Wavetrend.SD01L.Payload_Header} Wavetrend.SD01L.SensorErrorReport
 * @property {number[]} sensor
 */

/**
 * Issued by the device if a general device error is detected
 * @typedef {Wavetrend.SD01L.Payload_Header} Wavetrend.SD01L.GeneralErrorReport
 * @property {number} error_code
 * @property {string} file
 * @property {number} line
 */

/**
 * Format of data provided to the V3 decoder by TTN
 * @typedef {Object} TTN.DecoderInput
 * @property {number[]} bytes - array of received bytes
 * @property {number} fPort - LoRaWAN port number
 */

/**
 * Composite of all SD01L uplink messages
 * @typedef {Wavetrend.SD01L.InstallRequest|Wavetrend.SD01L.InstallResponse|Wavetrend.SD01L.StandardReport|Wavetrend.SD01L.AmbientReport|Wavetrend.SD01L.FreezeReport|Wavetrend.SD01L.ScaldReport|Wavetrend.SD01L.SensorErrorReport|Wavetrend.SD01L.GeneralErrorReport} Wavetrend.SD01L.Uplink_Payloads
 */

/**
 * Format of the result data expected by the V2 TTN decoder
 * @typedef {Object} TTN.DecoderOutput
 * @property {Wavetrend.SD01L.Uplink_Payloads} [data] - Decoded payload
 * @property {number} [fPort] - LoRaWAN port number
 * @property {string[]} warnings - any warnings generated by the decoding
 * @property {string[]} errors - any errors generated by the decoding
 */


/**
 * Wavetrend SD01L Payload Type (documented in encoder.js)
 * @ignore
 */
const SD01L_PAYLOAD_TYPE = {
    INSTALL_REQUEST: 0,
    CONFIGURATION: 1,
    INSTALL_RESPONSE: 2,
    STANDARD_REPORT: 3,
    AMBIENT_REPORT: 4,
    SCALD_REPORT: 5,
    FREEZE_REPORT: 6,
    LOW_BATTERY_REPORT_DEPRECATED: 7,
    SENSOR_ERROR_REPORT: 8,
    GENERAL_ERROR_REPORT: 9,
    SENSOR_DATA_DEBUG: 10,
};

const OFFSET_TYPE = 0
const OFFSET_VERSION = 1
const OFFSET_SEQUENCE = 2
const OFFSET_TIMESTAMP = 3

/**
 * Decode the common header fields
 * @param {number[]} bytes
 * @returns {Wavetrend.SD01L.Payload_Header}
 * @memberOf Wavetrend.SD01L
 */
function Decode_SD01L_PayloadHeader(bytes) {
    let i;
    let payload = { bytes: [] };

    for(i=0 ; i < bytes.length ; i++) {
        switch (i) {
            case OFFSET_TYPE:
                payload.type = unsignedByte(bytes[i]);
                break;
            case OFFSET_VERSION:
                payload.version = unsignedByte(bytes[i]);
                break;
            case OFFSET_SEQUENCE:
                payload.sequence = unsignedByte(bytes[i]);
                break;
            case OFFSET_TIMESTAMP:
                payload.timestamp =
                    (unsignedByte(bytes[i++]) << 24 >>> 0)
                    + (unsignedByte(bytes[i++]) << 16 >>> 0)
                    + (unsignedByte(bytes[i++]) << 8 >>> 0)
                    + unsignedByte(bytes[i]);
                break;
            default:
                payload.bytes = bytes.slice(i)
                i = bytes.length
        }
    }
    return payload;
}

/**
 * @memberOf Wavetrend.SD01L
 * @param {number} input - unsigned value
 * @returns {number} - signed representation of LSB of input
 */
function signedByte(input) {
    return (input & 0xFF) << 24 >> 24;
}

/**
 * @memberOf Wavetrend.SD01L
 * @param {number} input - unsigned value
 * @returns {number} - unsigned representation of LSB of input
 */
function unsignedByte(input) {
    return (input & 0xFF) >>> 0;
}

/**
 * Decode SD01L specific message payloads
 * @param {number[]} bytes
 * @returns {Wavetrend.SD01L.Uplink_Payloads}
 * @memberOf Wavetrend.SD01L
 */
function Decode_SD01L_Payload(bytes) {
    let payload = Decode_SD01L_PayloadHeader(bytes);
    bytes = payload.bytes;
    delete payload.bytes;
    let i = 0

    switch (payload.type) {
        case SD01L_PAYLOAD_TYPE.INSTALL_REQUEST:
            if (payload.version === 4) {
                payload.nonce =
                    (unsignedByte(bytes[i++]) << 24 >>> 0)
                    + (unsignedByte(bytes[i++]) << 16 >>> 0)
                    + (unsignedByte(bytes[i++]) << 8 >>> 0)
                    + unsignedByte(bytes[i++]);
                payload.battery_mV = (unsignedByte(bytes[i++]) << 8 >>> 0) + unsignedByte(bytes[i++]);
                payload.temperature = [];
                for (let sensor = 0; sensor < 3; sensor++) {
                    let temp_index = (unsignedByte(bytes[i++]) << 8 >>> 0) + unsignedByte(bytes[i++]);
                    payload.temperature[sensor] = (temp_index - 270) / 10
                }
                payload.firmware_version = {
                    major: unsignedByte(bytes[i++]),
                    minor: unsignedByte(bytes[i++]),
                    build: (bytes[i++] << 8 >>> 0) + unsignedByte(bytes[i++]),
                }
                payload.reset_reason = (bytes[i++] << 8 >>> 0) + unsignedByte(bytes[i++]);
            }
            break;

        case SD01L_PAYLOAD_TYPE.INSTALL_RESPONSE:
            if (payload.version === 1) {
                payload.error_code = unsignedByte(bytes[i++])
            }
            break;

        case SD01L_PAYLOAD_TYPE.STANDARD_REPORT:
            if (payload.version === 1) {
                payload.current = { sensor: [] };
                for (let sensor = 0; sensor < 3; sensor++) {
                    payload.current.sensor[sensor] = {
                        minC: signedByte(bytes[i++]),
                        maxC: signedByte(bytes[i++]),
                        events: unsignedByte(bytes[i++]),
                        reports: unsignedByte(bytes[i++]),
                    };
                }
                payload.history = [];
                for (let history = 0; history < 2 && i < bytes.length; history++) {
                    payload.history[history] = {
                        timestamp:
                            (unsignedByte(bytes[i++]) << 24 >>> 0)
                            + (unsignedByte(bytes[i++]) << 16 >>> 0)
                            + (unsignedByte(bytes[i++]) << 8 >>> 0)
                            + unsignedByte(bytes[i++]),
                        sensor: [],
                    };
                    for (let sensor = 0; sensor < 3; sensor++) {
                        payload.history[history].sensor[sensor] = {
                            minC: signedByte(bytes[i++]),
                            maxC: signedByte(bytes[i++]),
                            events: unsignedByte(bytes[i++]),
                            reports: unsignedByte(bytes[i++]),
                        };
                    }
                }
            }
            break;

        case SD01L_PAYLOAD_TYPE.AMBIENT_REPORT:
            if (payload.version === 0) {
                payload.minC = signedByte(bytes[i++]);
                payload.maxC = signedByte(bytes[i++]);
                payload.avgC = signedByte(bytes[i++]);
            }
            break;

        case SD01L_PAYLOAD_TYPE.FREEZE_REPORT:
        case SD01L_PAYLOAD_TYPE.SCALD_REPORT:
            if (payload.version === 0) {
                payload.sensor = unsignedByte(bytes[i++]);
                payload.temperature = signedByte(bytes[i++]);
            }
            break;

        case SD01L_PAYLOAD_TYPE.SENSOR_ERROR_REPORT:
            if (payload.version === 0) {
                payload.sensor = [];
                for (let sensor = 0; sensor < 3; sensor++) {
                    payload.sensor[sensor] = unsignedByte(bytes[i++])
                }
            }
            break;

        case SD01L_PAYLOAD_TYPE.GENERAL_ERROR_REPORT:
            if (payload.version === 0) {
                payload.error_code = (unsignedByte(bytes[i++]) << 8 >>> 0) + unsignedByte(bytes[i++]);
                payload.file = "";
                for (let pos = 0, append = true; pos < 32; pos++) {
                    if (append && bytes[i] !== 0) {
                        payload.file += String.fromCharCode(unsignedByte(bytes[i++]));
                    } else {
                        append = false;
                        i++;
                    }
                }
                payload.line = (unsignedByte(bytes[i++]) << 8 >>> 0) + unsignedByte(bytes[i++]);
            }
            break;

        case SD01L_PAYLOAD_TYPE.CONFIGURATION:
            throw "Configuration type is not a valid uplink message";

        case SD01L_PAYLOAD_TYPE.LOW_BATTERY_REPORT_DEPRECATED:
            throw "Low Battery Report is deprecated"

        case SD01L_PAYLOAD_TYPE.SENSOR_DATA_DEBUG:
            throw "Sensor Data Debug is not supported for decode"

        default:
            throw "Unrecognised Type Code"
    }
    return payload;
}

/**
 * Entry point for TTN V3 uplink decoder
 * @memberOf TTN
 * @param {TTN.DecoderInput} input
 * @returns {TTN.DecoderOutput} - object containing the result of the decode, which might include warnings or errors
 */
function decodeUplink(input) {
    let payload = {
        warnings: [],
        errors: [],
    }

    try {
        payload.data = Decode_SD01L_Payload(input.bytes);
    } catch (error) {
        payload.errors.push(error);
    }

    return payload;
}

/**
 * Entry point for TTN V2 uplink decoder
 * @memberOf TTN
 * @param {number[]} bytes - array of received bytes
 * @returns {Wavetrend.SD01L.Uplink_Payloads|null} - object containing decoded payload, or null if an error is encountered
 */
function Decoder(bytes /*, port */) {
  try {
      return Decode_SD01L_Payload(bytes);
  } catch(e) {
      return null
  }
}

// NB: Not used for TTN production, required for Unit Testing

if (typeof module !== 'undefined') {
    module.exports = {
        v2: Decoder,
        v3: decodeUplink,
        SD01L_PAYLOAD_TYPE,
    };
}